module SPLEval where
import SPLGrammar
import System.IO (isEOF)

type Map = (String, Type)
type Stack = [Map]

--Initial function to represent the initial state and begin evaluating expressions
eval :: [Exp] -> Stack -> IO Stack
eval [x] stack = evalExpr x stack
eval (x:xs)  stack = do
    newStack <- evalExpr x stack
    eval xs newStack
eval [] stack = do
    return stack


--Main function to pattern match and evaluate expressions generated by the grammar
evalExpr :: Exp -> Stack -> IO Stack

-- Handles if else statements
evalExpr (IfElse (Lookup name) exps1 exps2) stack 
    | (snd (getVar name stack)) == (Bool True) = (eval exps1 stack)
    | otherwise = (eval exps2 stack)

evalExpr (IfElse cond exps1 exps2) stack 
    | (evalTerminalExpr (cond,stack)) == (Bool True) = (eval exps1 stack)
    | otherwise = (eval exps2 stack)

    
-- Handles while statements   
evalExpr (While cond exps) stack
    | (evalTerminalExpr (cond,stack)) == (Bool True) = 
        do
            newStack <- eval exps stack
            evalExpr (While cond exps) newStack
    | otherwise = eval [] stack 


-- Handles output to console
evalExpr (Print (Lookup exp)) stack = do 
    let foundVar = getVar exp stack
    putStrLn (printVar foundVar)  
    return stack

evalExpr (Print (GetIndex x (Lookup name))) stack = do
    let foundVar = getVar name stack
    let valueAtIndex = getIndex (evalTerminalExpr (x,stack)) foundVar
    putStrLn (printVal valueAtIndex)
    return stack

evalExpr (Print (Type (Arr exp))) stack = do 
    putStrLn (printArr exp)
    return stack

evalExpr (Print (Type exp)) stack = do 
    putStrLn (printVal exp)
    return stack

evalExpr (Print exp) stack = do
    putStrLn (printVal (evalTerminalExpr (exp,stack)))
    return stack
    

-- Declare NULL variable
-- If variable is declared without an initial value, it is marked with "NULL"
-- Does NOT check if variable is already declared
evalExpr (Declare var) stack = do
    return (declareVar var stack)


-- Declare with value of an already existing variable
evalExpr (DeclareWithVal name (Lookup varName)) stack = 
    evalExpr(DeclareWithVal name (Type (snd (getVar varName stack)))) stack
    
-- Declare with index of an array
evalExpr (DeclareWithVal name (GetIndex i (Lookup arrName))) stack = 
    evalExpr (DeclareWithVal name (Type (getIndex (evalTerminalExpr (i,stack)) (getVar arrName stack)))) stack
    
-- Declare with an absolute value
evalExpr (DeclareWithVal name (Type val)) stack = do
    let stack' = declareVar name stack
    let stack'' = assignVar name val stack'
    return stack''

-- Declare with the result from reading a line from stdin    
evalExpr (DeclareWithVal name ReadLine) stack = do
    endReached <- isEOF 
    if endReached -- if end of file reached,
        then do
            let val = (Arr [])
            let stack' = declareVar name stack
            let stack'' = assignVar name val stack'
            return stack''
        else do
            line <- getLine
            let val = parseInput line
            let stack' = declareVar name stack
            let stack'' = assignVar name val stack'
            return stack''

-- Declare with result of an operation
evalExpr (DeclareWithVal name exp) stack = 
    evalExpr(DeclareWithVal name (Type (evalTerminalExpr (exp,stack)))) stack


-- Operations on arrays
evalExpr(Pop (Lookup name)) stack = do
    let foundVar = getVar name stack
    let array = getArrayVal (snd foundVar)
    let newArray = popArr array
    let newVar = Arr newArray
    let stack' = assignVar name newVar stack
    return stack'

evalExpr(DeQ (Lookup name)) stack = do
    let foundVar = getVar name stack
    let array = getArrayVal (snd foundVar)
    let newArray = deqArr array
    let newVar = Arr newArray
    let stack' = assignVar name newVar stack
    return stack'

evalExpr (Push (Type newVal)(Lookup name)) stack = do 
    let foundVar = getVar name stack
    let array = getArrayVal (snd foundVar)
    let newArray = push newVal array
    let newVar = Arr newArray
    let stack' = assignVar name newVar stack
    return stack'

evalExpr (Push exp1 exp2) stack = 
    evalExpr (Push (Type (evalTerminalExpr (exp1,stack))) exp2 ) stack

evalExpr (EnQ (Type newVal)(Lookup name)) stack = do 
    let foundVar = getVar name stack
    let array = getArrayVal (snd foundVar)
    let newArray = enq newVal array
    let newVar = Arr newArray
    let stack' = assignVar name newVar stack
    return stack'

evalExpr (EnQ exp1 exp2) stack = 
    evalExpr (EnQ (Type (evalTerminalExpr (exp1,stack))) exp2 ) stack

evalExpr (AssignArr name (Type (Int index)) (Type value)) stack = do 
    let foundVar = getVar name stack
    let array = getArrayVal (snd foundVar)
    let stack' = assignVar name (Arr (replaceAtIndex index array value )) stack
    return stack'

evalExpr (AssignArr name exp1 exp2) stack =
    evalExpr (AssignArr name(Type (evalTerminalExpr (exp1,stack))) (Type (evalTerminalExpr (exp2,stack))) ) stack


-- Assigns new value to already declared variable
-- Does NOT check if variable is already declared
evalExpr (Assign name (Lookup varName)) stack = 
    evalExpr (Assign name (Type (snd (getVar varName stack)))) stack

-- Assign with index of array
evalExpr (Assign name (GetIndex i (Lookup arrName))) stack = 
    evalExpr (Assign name (Type (getIndex (evalTerminalExpr (i,stack)) (getVar arrName stack)))) stack

-- Assign with absolute value
evalExpr (Assign name (Type value)) stack = do 
    return (assignVar name value stack)

evalExpr (Assign name ReadLine) stack = do
    endReached <- isEOF 
    if endReached -- if end of file reached,
        then do
            let val = (Arr [])
            let stack' = assignVar name val stack
            return stack'
        else do
            line <- getLine
            let val = parseInput line
            let stack' = assignVar name val stack
            return stack'

-- pops array and stores the popped value in a variable
evalExpr(Assign name (Pop (Lookup arrName))) stack = do
    -- modify
    let foundArr = getVar arrName stack
    let poppedVal = (pop (getArrayVal (snd foundArr)))
    let stack' =  assignVar name poppedVal stack
    let stack'' = assignVar arrName (Arr (popArr (getArrayVal (snd foundArr)))) stack'
    return stack''

-- same as pop but dequeue
evalExpr(Assign name (DeQ (Lookup arrName))) stack = do
    -- modify
    let foundArr = getVar arrName stack
    let poppedVal = (deque (getArrayVal (snd foundArr)))
    let stack' =  assignVar name poppedVal stack
    let stack'' = assignVar arrName (Arr (deqArr (getArrayVal (snd foundArr)))) stack'
    return stack''
-- Assign with result of an operation
evalExpr (Assign name exp) stack = 
    evalExpr (Assign name (Type (evalTerminalExpr (exp,stack)))) stack

-- Read and print out a single line e.g. readLine;
evalExpr (readLine) stack = do
    line <- getLine
    putStrLn(line)
    return stack


-- General Operations
evalTerminalExpr:: (Exp,Stack) -> Type
evalTerminalExpr((Type (Bool b)),stack) = (evalBool ((Type (Bool b)),stack))
evalTerminalExpr((NOT x),stack) = (evalBool ((NOT x),stack))
evalTerminalExpr ((AND x1 x2),stack) = (evalBool ((AND x1 x2),stack))
evalTerminalExpr ((OR x1 x2),stack) = (evalBool ((OR x1 x2),stack))
evalTerminalExpr ((IsEq x1 x2),stack) = (evalBool ((IsEq x1 x2),stack))
evalTerminalExpr ((IsLess x1 x2),stack) = (evalBool ((IsLess x1 x2),stack))
evalTerminalExpr ((IsMore x1 x2),stack) = (evalBool ((IsMore x1 x2),stack))
evalTerminalExpr (exp,stack) = (Int (evalOp (exp,stack)))

    
-- Arithmetic Operators, now with variables!
evalOp :: (Exp,Stack) -> Int
evalOp ((Plus x1 x2),stack) = (evalOp (x1,stack)) + (evalOp (x2,stack))
evalOp ((Minus x1 x2),stack) = (evalOp (x1,stack)) - (evalOp (x2,stack))
evalOp ((Times x1 x2),stack) = (evalOp (x1,stack)) * (evalOp (x2,stack))
evalOp ((Div x1 x2),stack) = div (evalOp (x1,stack)) (evalOp (x2,stack))
evalOp ((Type (Int x)),stack) = x
evalOp ((Lookup name),stack) = evalOp ((Type (snd (getVar name stack))),stack)
evalOp ((Length (Lookup name)),stack) = (arrLength 0 (getVar name stack))
evalOp ((GetIndex index (Lookup arrName)),stack) = evalOp((Type (getIndex (Int (evalOp (index,stack))) (getVar arrName stack))),stack)



-- Boolean operations
evalBool :: (Exp,Stack) -> Type
evalBool (Type (NULL),stack) = NULL
evalBool (Type (Bool b),stack) = (Bool b)
evalBool (Type (String s),stack) = (String s)
evalBool (Type (Int x),stack) = (Int x)
evalBool ((Length (Lookup name)),stack) = (Int (arrLength 0 (getVar name stack)))
evalBool ((GetIndex index (Lookup arrName)),stack) = (getIndex (Int (evalOp (index,stack))) (getVar arrName stack))
evalBool ((AND x1 x2),stack) = (andType ((evalBool(x1,stack)),(evalBool(x2,stack))))
evalBool ((OR x1 x2),stack) = (orType ((evalBool(x1,stack)),(evalBool(x2,stack))))
evalBool ((NOT exp),stack) =  negateType(evalBool(exp,stack))
evalBool ((Lookup name),stack) = evalBool((Type (snd (getVar name stack))),stack)
evalBool ((IsEq x1 x2),stack) = (Bool ((evalBool (x1,stack)) == (evalBool(x2,stack))))
evalBool ((IsLess x1 x2),stack) = (lessType ((evalBool(x1,stack)),(evalBool(x2,stack))))
evalBool ((IsMore x1 x2),stack) = (moreType ((evalBool(x1,stack)),(evalBool(x2,stack))))
evalBool ((Plus x1 x2),stack) = (Int (evalOp ((Plus x1 x2),stack)))
evalBool ((Minus x1 x2),stack) = (Int (evalOp ((Minus x1 x2),stack)))
evalBool ((Times x1 x2),stack) = (Int (evalOp ((Times x1 x2),stack)))
evalBool ((Div x1 x2),stack) = (Int (evalOp ((Div x1 x2),stack)))

negateType :: Type -> Type
negateType (Bool b) = Bool (not b)

andType :: (Type,Type) -> Type
andType ((Bool b1),(Bool b2)) = (Bool (b1 && b2))

orType :: (Type,Type) -> Type
orType ((Bool b1),(Bool b2)) = (Bool (b1 || b2))

lessType :: (Type,Type) -> Type
lessType ((Int x),(Int y)) = (Bool (x < y))

moreType :: (Type,Type) -> Type
moreType ((Int x),(Int y)) = (Bool (x > y))


-- Operations on expressions 
declareVar :: String -> Stack -> Stack
declareVar name stack = (name, NULL):stack


-- Finds variable inside the stack and changes its value. Works with expressions
assignVar :: String -> Type -> Stack -> Stack
assignVar name (Int value) stack = replaceVar (name,(Int value)) stack
assignVar name (String value) stack = replaceVar (name,(String value)) stack
assignVar name (Bool value) stack = replaceVar (name,(Bool value)) stack
assignVar name (Arr value) stack = replaceVar (name,(Arr value)) stack


-- utility function for assignVar that takes a variable, replaces the value in the stack
replaceVar :: Map -> Stack -> Stack
replaceVar (name,value) ((mapName,mapValue):maps)
    | name == mapName = ((mapName,value):(replaceVar (name,value) maps))
    | otherwise = ((mapName,mapValue):(replaceVar (name,value) maps))
replaceVar map [] = []


-- Finds variable inside the stack by given name
getVar :: String -> Stack -> Map
getVar name stack = head(filter ((==name).fst) stack) 


-- Returns an element at index position in the array
getIndex :: Type -> Map -> Type
getIndex (Int i) (name,Arr (x:xs))
    | i == 0 = x
    | i < 0 = NULL
    | otherwise = (getIndex (Int (i-1)) (name, (Arr xs)))
getIndex (Int i) (name, Arr []) = NULL


-- Replaces element at index
replaceAtIndex:: Int -> [Type] -> Type -> [Type]
replaceAtIndex index arr val = (merge ((fst (splitAt (index) arr))++[val]) (tail(snd(splitAt (index) arr))))


-- handles queue/stack features
push:: Type -> [Type] -> [Type]
push val (x:xs) =((x:xs)++[val])
push val [] = [val]

enq:: Type -> [Type] -> [Type]
enq val x =(val:x)

pop:: [Type] -> Type
pop x = (last x)

popArr :: [Type] -> [Type]
popArr [] = []
popArr x = (init x)

deque:: [Type] -> Type
deque x = (head x)

deqArr:: [Type] -> [Type]
deqArr (x:xs) = xs
deqArr [] = []

-- concatenates two arrays
merge :: [Type] -> [Type] -> [Type]
merge xs     []     = xs
merge []     ys     = ys
merge (x:xs) (y:ys) = x : y : merge xs ys


-- Returns array length
arrLength :: Int -> Map -> Int
arrLength i (name, Arr (x:xs)) = arrLength (i+1) (name,Arr xs)
arrLength i (name, Arr []) = i


-- Returns value stored in a variable as a String 
printVar :: Map -> String
printVar (name, String val) = val
printVar (name, Int val) = show val
printVar (name, Bool val) = show val
printVar (name, NULL) = "Null Value"
printVar (name, Arr xs) = printArr xs

-- Returns free value as a String
printVal :: Type -> String
printVal (Bool b) = show b
printVal (Int i) = show i
printVal (String s) = s
printVal (NULL) = show NULL

getArrayVal :: Type -> [Type]
getArrayVal (Arr arr) = arr

-- Prints out array
printArr :: [Type] -> String
printArr((Int x):xs) = show x ++ " " ++ printArr(xs)
printArr((String x):xs) = x ++ " " ++ printArr(xs)
printArr((Bool x):xs) = show x ++ " " ++ printArr(xs)
printArr([]) = ""


-- Utility functions for reading a line and converted to array
parseInput :: String -> Type
parseInput sentence = (Arr (convertIntArrToType (convertCharsToInts (words sentence))))

convertIntArrToType :: [Int] -> [Type]
convertIntArrToType (x:xs) = (Int x):(convertIntArrToType xs)
convertIntArrToType [] = [] 

convertCharsToInts :: [String] -> [Int]
convertCharsToInts (x:xs) = (read x :: Int):(convertCharsToInts xs)
convertCharsToInts [] = []